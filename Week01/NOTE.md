# 学习笔记

## 预习课学习方法总结

### 三分看视频、七分练习

- 视频学习：
最佳办法：1.5~2.0 倍速播放、难点（暂停 + 反复）<br>
最差办法：原速只看一遍

> 我的理解：此方法适用于所有的视频学习，高效！

### 摒弃“旧”习惯-最重要

- **不要死磕**（传统方式）
  **五遍刷题法（五毒神掌）**（敢于放手、敢于死记硬背代码）
  **不懒于看高手代码**（国际版的高票回答）
- 最佳方式：**5分钟做不出来，直接看题解或者高票代码，用五毒神掌变成自己的东西。**
- 最差方式：死磕和只刷一遍AC了事。

**最大误区：LeetCode题目只做一遍！（90%素人、30学员）**

> 我的旧习惯：死磕不服输，AC了事

## 第一课 数据结构预算法总览

### 有效学习数据结构与算法

**预习 + 课堂互动 + 切题法完成课后作业**

> 我的目标：
> - 顶尖水平（不断超越自己）— 对算法数据结构有理解，应用于平常项目开发中，优化代码。<br>
> - 一线互联网公司面试 — 面试的时候不至于无从下手。<br>
> - LeetCode 300+ 的积累。<br>

### 《异类：不一样的成功启示录》和精通一个领域

- Chunk it up 切碎知识点
- Deliberate Practicing 刻意练习
- Feedback 反馈

#### 切碎知识点：分解数据结构与算法

见：数据结构与算法导图.pdf

#### 刻意练习

- 刻意练习，过遍数（五毒神掌）
- 练习缺陷、弱点地方
- 克服不舒服、不爽、枯燥

#### 反馈

- 即时反馈
- 主动反馈：
学习高手代码（GitHub、LeetCode、etc.），思想和技巧，通过五毒神掌变成自己的东西。

### 刷题技巧

#### 切题四件套：知而行之

- Clarification：读题，看清并理解题目，不要急于答题。
- Posible Solutions：找出所有可能的题解（自己能的）。
	- compare(time/space)：比较时间复杂度和空间复杂度
	- optimal（加强）：写出一遍，优化，看高手代码，理解并能默写，五遍刷题法。
- Coding（多写）：多写，多参考，24小时后，一周后，面试前
- Test cases：测试用例。

#### 五遍刷题法—五毒神掌

##### 刷题第一遍
- 5分钟：读题 + 思考
- 直接解法：注意！多解法，比较解法优劣（时间复杂度和空间复杂度）。
- 背诵、默写好的解法。

##### 刷题第二遍

- 马上自己写--> LeetCode 提交
- 多种解法比较、体会 --> 优化

##### 刷题第三遍

- 过了一天后，再重复做题
- 不同解法的熟练程度 --> 专项练习

##### 刷题第四遍

- 过了一周：反复练习相同题目。

##### 刷题第五遍

- 面试前一周恢复性训练


## 第二课 训练准备和复杂度分析

### 第一节 训练环境设置、编码技巧和Code Style

#### LeetCode

- leetcode-cn.com 和 题解 
- leetcode.com 国际站 和 Discuss board
- leetcode 插件（idea)

#### 自顶向下编程（思路清晰）


### 第二节 时间复杂度、空间复杂度

#### Big O notation

- O(1)：Constant Complexity 常数复杂度，如常数次数打印
- O(log n)：Logarithmic Complexity 对数复杂度，如：二分查找，调表，二叉搜索树查找。
- O(n)：Linear Complexity 线性时间复杂度，如，单层循环
- O(n^2)：N Square Complexity 平方，如：双层循环（通常的）
- O(n^3)：N cubic Complexity  立方，如：三层循环（通常）
- O(2^n)：Exponential Grouth 指数，斐波那契（直接用递归，不作缓存）
- O(n!)：Factorial 阶乘

> 二叉树遍历 -前序、中序、后续：O(n) <br>
> 图的遍历：O(n)<br>
> 搜索算法：DFS、BFS：O(n)<br>
> 二分查找：O(log n)<br>

#### 主定理

见课件第二课23页

---

## 第三课 数组链表和跳表

### 数组、链表、跳表基本实现和特征

#### Array 数组

- 查询快，O(1)
- 插入、删除慢，O(n)

#### Linked List 链表

head: Node(value: Object，next: Node) -> node: Node(value: Object，next: Node) -> ... -> tail: Node(value: Object，next: Node) -> null

- 查询慢，O(n)
- 插入、删除快，O(1)

#### 跳表

##### 跳表的特点

**注意只能用于元素有序的情况**

跳表（skip list）对标的是平衡树和二分查找，1989年出现

- 普通链表：查询慢，O(n)；插入、删除快，O(1)
- 跳表：**插入、删除、查询（搜索）都是O(log n)**

最大的优势是原理简单、容易实现、方便扩展、效率更高。
在一些热门的项目里用来代替平衡树，如Redis、LevelDB等。

##### 如何给有序链表加速

**添加多级索引（升维）**
**以空间换时间**

##### 跳表的时间复杂度和空间复杂度分析

- 时间复杂度：查询 O(log n)
- 空间复杂度：O(n)


#### 工程中应用

- LRU Cache - Linked List
- Redis - Skip List


## 第四课 栈、队列、双端队列、优先队列

### 第一节 栈和队列的节本实现和特征


- **栈 Stack：后入先出，添加、删除皆为O(1)**（Last in - Fist out， LIFO），进push，出pop
- **队列 Queue：先入先出，添加、删除皆为O(1)**（Last in - Last out，Fist in - Fist out）

#### Deque：Double-End Queue 双端队列

1. 简单理解：两端都可以进出的 Queue
2. 插入和删除都是O(1)操作

#### Stack、Queue、Deque 的工程实现

- Stack<T>：push(T t)、pop(): T
- Queue<T>：offer(T t)、poll(): T、peek(): T
- Deque<T>: push(T t)、peek(): T、pop(): T

#### 优先队列

1. 插入操作：O(1)
2. 取出操作：O(log n) - 按照元素的优先级取出
3. 底层具体实现的数据结构较为多样和复杂：heap、bst、treap

#### 复杂度分析
见课件第四课17页















